suppressMessages(require(mixtools, quietly = T))


rep.row<-function(x,n){
  matrix(rep(x,each=n),nrow=n)
} # the function is used to pre-allocate the matrix 

# the function is used to return a vecor where each entry is the sum of each element
# at same column position but different row. The new vector is used as normalizing factor
# to compute each d{kth}
sum.row <- function(A){
  res_vec <- rep(0, ncol(A))
  for (i in 1:nrow(A)){
    res_vec <- res_vec + A[i,]  
  }
  return(res_vec)
} 


handmade.em <- function(y, p, mu, sigma, n_iter, plot_flag = T, k)
{
  
  like <- 0
  for (i in 1:k){
    cols     <- c(rgb(1,0,0,.3), rgb(0,1,0,.3), rgb(0,0,1,.3))
    like <- like + p[i]*dnorm(y, mu[i], sigma[i])
  }

  deviance <- -2*sum(log(like))
  res      <- matrix(NA,n_iter + 1, 2+3*k)
  res[1,]  <- c(0, p, mu, sigma, deviance)
  
  d_tot <- rep.row(rep(NA,length(y)),k)
  r_tot <- rep.row(rep(NA,length(y)),k)
  for (iter in 1:n_iter) {
    
    # E step
    for (j in 1:k) {
      d_tot[j,] <- p[j]*dnorm(y, mu[j], sigma[j])
    }
    for (j in 1:k) {
      r_tot[j,] <- d_tot[j,]/sum.row(d_tot)
    }
    
    # M step
    for (j in 1:k){
      r = r_tot[j,]
      p[j]     <- mean(r)
      mu[j]    <- sum(r*y)/sum(r)
      sigma[j] <-sqrt( sum(r*(y^2))/sum(r) - (mu[j])^2 )
    }
    
    # -2 x log-likelihood (a.k.a. deviance)
    like <- 0
    for (i in 1:k){
      like <- like + p[i]*dnorm(y, mu[i], sigma[i])
    } 
    deviance <- -2*sum( log(like) )
    
    # Save
    res[iter+1,] <- c(iter, p, mu, sigma, deviance)
    
    # Plot
    if (plot_flag){
      hist(y, prob = T, col = gray(.8), breaks=50, border = NA, 
           main = "", xlab = paste("EM Iteration: ", iter, "/", n_iter, sep = ""))
      set.seed(123)
      points(jitter(y), rep(0,length(y)), 
             pch = 19, cex = .6, 
             #col = cols[ (dnorm(y,mu[1],sigma[1]) > dnorm(y,mu[2],sigma[2]))],
             )
      
      likefunction <- function(y){
        like <- 0
        for (i in 1:k){
          #cols     <- c(rgb(1,0,0,.3), rgb(0,1,0,.3), rgb(0,0,1,.3))
          like <- like + p[i]*dnorm(y, mu[i], sigma[i])
        }
        return(like)
      }
      
      curve(likefunction(x),
            lwd = 4, col = rgb(0,0,0,.5), add = TRUE)
      Sys.sleep(1.5)
    }
  }
  res <- data.frame(res)
  #names(res) <- c("iteration","p1","p2","mu1","mu2","sigma1","sigma2","deviance")
  out <- list(parameters = c(p = p, mu = mu, sigma = sigma), deviance = deviance, res = res)
  return(out)
}


n <- 250 # Sample size
XX <- rnormmix(n,
               lambda = c(0.5, rep(0.1,5)),
               mu = c(0, ((0:4)/2)-1),
               sigma = c(1, rep(0.1,5)) )

hist(XX, prob = T, col = "pink",
     border = "white", breaks = 50, 
     main = "Bart Simpson", 
     xlab = "")

hem_fit <- handmade.em(XX, 
                       p      = c(.5,.5),#c(.3, .2, .5),#c(.3, .2, .1,.25,.15), 
                       mu     = c(-2,2),#c(-2,0,1),#c(45,55,50, 48, 46), 
                       sigma  = c(2,2),#c(2,2,2),#c(8,8, 8, 8, 8), 
                       n_iter = 20,
                       plot_flag = T,
                       k=2)
round( hem_fit$parameters, 3 )
hem_fit$deviance

#data("faithful")
#?faithful
#hem_fit <- handmade.em(faithful$eruptions, 
#                       p      = c(.3, .2, .5),#c(.3, .2, .1,.25,.15), 
#                       mu     = c(45,55,50),#c(45,55,50, 48, 46), 
#                       sigma  = c(8,8,8),#c(8,8, 8, 8, 8), 
#                       n_iter = 10,
#                       plot_flag = T,
#                       k=3)
#round( hem_fit$parameters, 3 )
#hem_fit$deviance
#
